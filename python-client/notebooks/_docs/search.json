[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "assign-uprn",
    "section": "",
    "text": "python wrapper for ASSIGN API calls",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "index.html#about",
    "href": "index.html#about",
    "title": "assign-uprn",
    "section": "About",
    "text": "About\n\ndocs\n\nhttps://joeldn.srht.site/assign-uprn\n\ncode\n\nhttps://git.sr.ht/~joeldn/assign-uprn\n\nlicense\n\nAGPLV3",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "assign-uprn",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall from pypi\n$ pip install assign_uprn\n\n\nBackground\n\nAddress-to-UPRN matching algorithm\n\nIn partnership with researchers at Queen Mary University of London’s Clinical Effectiveness Group, Endeavour Health has developed an address-matching algorithm to link patient health records to geospatial information. Linking people to places can help researchers understand how health is impacted by social and environmental factors, like the characteristics of a household, green space or air pollution. But patient addresses are entered into GP records as free text so the same address can be written in different ways, making data linkage very difficult.\n\n\nThe algorithm, known as ASSIGN (AddreSS MatchInG to Unique Property Reference Numbers), allocates a Unique Property Reference Number (UPRN) to patient records\n\n\nEvery property in the UK already has a UPRN. They are allocated by local authorities and made nationally available by Ordnance Survey. A UPRN gives every address a standardised format, enabling pseudonymised linkage to other sources of data.\n\n\nASSIGN compares addresses in freetext form with the Ordnance Survey’s “Address Base Premium” UPRN database, one element at a time, and decides whether there is a match. The algorithm mirrors human pattern recognition, so it allows for certain character swaps, spelling mistakes and abbreviations. After rigorous testing and adjustments, ASSIGN correctly matches 98.6% of patient addresses at 38,000 records per minute. It also includes patients’ past addresses, making it possible to study addresses across the life span.\n\n\nThe address matching algorithms use a human mediated best fit method to match a candidate address to one address from the set of all available ‘standard’ addresses.\n\n\nThe algorithms use human semantic pattern recognition, applying rankings of matching judgements following rules that manipulate the text, supported by a few machine based algorithms such as the Levenshtein distance algorithm.\n\n\nThe rankings, which can be considered as a set of numbers, 1-n, could be described as a plausibility measure, as opposed to a probability measure or deterministic measure.\n\ndocs | code\n\n\nUPRN de-identification\nASSIGN can also de-identify UPRNs into Residential Anonymised Linkage Fields (RALFs). These are locations that are pseudo-anonymised by encrypting them using a salt, which has itself been encrypted by a research governance function and the openpseudobymiser website:\n\nhttps://www.openpseudonymiser.org\n\nDifferent datasets with UPRNs, such as council records and health records, can be de-identified using the same salt, and then linked anonymously for research purposes by anonymising the home UPRN of the person into a RALF.\n\n\n\n\n\n\nNoteA note on re-identification\n\n\n\n\n\nIt’s worth noting that whilst de-identified data protects information about individuals, it can potentially be re-identified by association with other datasets, as explained in the following excerpt from Cory Doctorow’s blog:\n\nhttps://pluralistic.net/2024/03/08/the-fire-of-orodruin/\n\n\n…it is surprisingly easy to “re-identify” individuals in anonymous data-sets. To take an obvious example: we know which two dates former PM Tony Blair was given a specific treatment for a cardiac emergency, because this happened while he was in office. We also know Blair’s date of birth. Check any trove of NHS data that records a person who matches those three facts and you’ve found Tony Blair – and all the private data contained alongside those public facts is now in the public domain, forever.\n\n\nNot everyone has Tony Blair’s reidentification hooks, but everyone has data in some kind of database, and those databases are continually being breached, leaked or intentionally released. A breach from a taxi service like Addison-Lee or Uber, or from Transport for London, will reveal the journeys that immediately preceded each prescription at each clinic or hospital in an “anonymous” NHS dataset, which can then be cross-referenced to databases of home addresses and workplaces. In an eyeblink, millions of Britons’ records of receiving treatment for STIs or cancer can be connected with named individuals – again, forever.\n\nUsing de-identified UPRNs in datasets does not completely eliminate the risk of person-level records being re-identified. For this reason, an alternative research data management practice is now being using by organisations such as OpenSAFELY:\n\nhttps://www.opensafely.org\n\nOpenSAFELY retains identifiable records in a secure location whilst researchers prepare their analysis code on synthetic data, including the ability to produce disclosure controlled outputs. Researchers submit their code to OpenSAFELY, which runs it against real data, and the disclosure controls are checked by moderators prior to release back the researhers. This way, row-level information about individuals is protected against identification.",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "assign-uprn",
    "section": "Dependencies",
    "text": "Dependencies\n\nAPI Access\n\n\nLicense to use AddressBase Premium\nAddressBase Premium usage is typically used by public service providers under the terms of the Public Services Geospatial Mapping Agreement (PSGA). You can check whether you are licensed to use this data with the following lookup:\n\nhttps://www.ordnancesurvey.co.uk/customers/public-sector/psga-member-finder\n\n\n\nAPI access and authentication\nEndeavour health manage access, and provide the API endpoints, usernames, and passwords that support API usage:\n\nhttps://endeavourhealth.org\n\n\n\nPython packages used by this module\nthe following packages dependencies need to be available in the python environment used by this package\n# pip install requests, used to interact with the API\nimport requests\n# pip install python-dotenv, note that other dot env packages exist\nfrom dotenv import load_dotenv\n\nWorking with python-dotenv\nCreate a .env file in the project root containing the following variables used by the package:\nASSIGN_ENDPOINT=endpoint\nASSIGN_USER=username\nASSIGN_PASS=password\n.env is explicitly excluded from version control by .gitignore which keeps your authentication credentials separate from the codebase.\nThe contents of .env will contain authentication credentials provided by endeavour health with the contents resembling the following structure:\n\n\n\nDe-identification salt\nTo obtain RALFs, your research governance function can support you to obtain a salt they have previously encrypted with the openpseudonymiser website using a salt phrase created for the research project being conducted:\n\nhttps://www.openpseudonymiser.org\n\nThe salt is encrypted using a private key known only to The University of Nottingham (the maintainers of openpseudonymiser).",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "index.html#using-the-api",
    "href": "index.html#using-the-api",
    "title": "assign-uprn",
    "section": "Using the API",
    "text": "Using the API\n\nSingle address check\nA single address can be sent for matching within a single HTTP request. A search for 10+Downing+St,Westminster,London,SW1A2AA would receive the following response:\n{\n   \"Address_format\":\"good\",\n   \"Postcode_quality\":\"good\",\n   \"Matched\":true,\n   \"BestMatch\":{\n      \"UPRN\":\"100023336956\",\n      \"Qualifier\":\"Property\",\n      \"LogicalStatus\":\"1\",\n      \"Classification\":\"RD04\",\n      \"ClassTerm\":\"Terraced\",\n      \"Algorithm\":\"10-match1\",\n      \"ABPAddress\":{\n         \"Number\":\"10\",\n         \"Street\":\"Downing Street\",\n         \"Town\":\"City Of Westminster\",\n         \"Postcode\":\"SW1A 2AA\"\n      },\n      \"Match_pattern\":{\n         \"Postcode\":\"equivalent\",\n         \"Street\":\"equivalent\",\n         \"Number\":\"equivalent\",\n         \"Building\":\"equivalent\",\n         \"Flat\":\"equivalent\"\n      }\n   }\n}\n\n\nUploading an encrypted salt\nIf you wish to de-identify the UPRNS, please ask your data governance function to provide you with a .EncryptedSalt file from the openpseudonymiser website. You can then use the provided upload function to send this to the API.\nFrom then on, addresses batch uploaded with the upload function will not only be UPRN matched, but a RALF will be provided too (see the Example download file content in this document).\n\n\nMultiple address checking\nMultiple addresses can be uploaded within a text file which is processed immediately after the file has been uploaded, and downloaded shortly afterwards.\n\n\nUpload\nThe maximum number of address candidates that you can upload in a single file is 100,000.\nThe address file to be uploaded must:\n\nhave a .txt extension\ninclude no headers\ncontain two columns separated by a single tab character\n\nThe first line must not contain any header information\nThe first column is a unique numeric row id\nThe second column is the address (with commas between each address line)\n\n\n\nExample upload file content:\n1⭾10 Downing St,Westminster,London,SW1A2AA\n3⭾Bridge Street,London,SW1A 2LW\n4⭾221b Baker St,Marylebone,London,NW1 6XE\n5⭾3 Abbey Rd,St John's Wood,London,NW8 9AY\n\n\n\nDownload\nUploads are processed straightaway and can be downloaded by referencing the name of the upload file in the API call. The download includes data from AddressBase Premium (plus a RALF if you’ve previously uploaded a .EncryptedSalt file):\n\nExample download file content:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nid\nuprn\naddress_fmt\nalgorithm\nclassification\nmatch_building\nmatch_flat\nmatch_number\nmatch_postcode\nmatch_street\nabp_number\nabp_postcode\nabp_street\nabp_town\nqualifier\nadr_candiddate\nabp_building\nlatitude\nlongitude\npoint\nx\ny\nralf\nclassification_term\nabp_flat\nlogical_status\n\n\n\n\n1\n100023336956\n\n10-match1\nRD04\nequivalent\nequivalent\nequivalent\nequivalent\nequivalent\n10\nSW1A 2AA\nDowning Street\nCity Of Westminster\nProperty\n10 Downing St,Westminster,London,SW1A2AA\n\n51.5035410\n-.1276700\n51.5035410\n530047.00\n179951.00\nC30921C8404087803C3687301351FF41CCB4A5E8F3691070723293C8BD654CBB\nTerraced\n\n1\n\n\n2\n200002501505\n\n550-match5a\nPP\ncandidate field dropped\nequivalent\nequivalent\nequivalent\nequivalent\n\nSW1A 2LW\nBridge Street\nCity Of Westminster\nProperty\nBridge Street,London,SW1A 2LW\nPortcullis House\n51.5013476\n-.1243451\n51.5013476\n530284.00\n179713.00\n4D19E2EB66A2C12BD56B93D96CFBBE5B74525AEFC4C68329BE87B55C43EA4C36\nProperty Shell\n\n1\n\n\n3\n100023071949\n\n3200-match61A170\nCR08\nmoved from Number\nequivalent\nmoved to Building\nequivalent\nequivalent\n\nNW1 6XE\nBaker Street\nLondon\nProperty\n221b Baker St,Marylebone,London,NW1 6XE\n221B\n51.5237510\n-.1585550\n51.5237510\n527847.00\n182144.00\n7727B90C7C3A744AF6FD8D5A4FEB6767B1EACBBC721B85EED6AE86EDD2B0BA9C\nShop / Showroom\n\n1\n\n\n4\n100023122909\n\n40-match1\nCR08\nmoved from Street\nmoved from Number\nmoved from Flat\nequivalent\nmoved from Building\n3\nNW8 9AY\nAbbey Road\nCity Of Westminster\nProperty\n3 Abbey Rd,St Johns Wood,London,NW8 9AY\n\n51.5321562\n-.1779541\n51.5321562\n526478.00\n183045.00\n6E479D3F8DA8A548C631622EA8640E1CE9030289C5ED4458B91A4F6C4F92C799\nShop / Showroom\n\n1",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "assign-uprn",
    "section": "Developer Guide",
    "text": "Developer Guide\nThis project uses nbdev which uses notebooks to create the package the module, tests, documentation (using quarto), and makes git versioning cleaner by removing notebook metadata prior to commits:\n\nhttps://nbdev.fast.ai/\n\n\nWorking on the assign-uprn module\n# install assign_uprn package as a developer\n$ pip install -e '[.dev]'\n\n# make changes to notebooks in the nbs/ directory\n# ...\n\n# clean the notebook metadata to make git history cleaner\n$ nbdev_clean\n\n# compile to have changes apply to assign_uprn module, and run tests\n$ nbdev_prepare\n\n# build the static website with quarto (https://quarto.org/)\n$ nbdev_docs\n\n# local preview of the website with quarto\n$ nbdev_preview",
    "crumbs": [
      "assign-uprn"
    ]
  },
  {
    "objectID": "02_api_calls_tests.html",
    "href": "02_api_calls_tests.html",
    "title": "api calls tests",
    "section": "",
    "text": "check the api calls are working as expected\n::: {#cell-2 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\n:::\n::: {#cell-3 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\n:::",
    "crumbs": [
      "api calls tests"
    ]
  },
  {
    "objectID": "02_api_calls_tests.html#test-single-address-check",
    "href": "02_api_calls_tests.html#test-single-address-check",
    "title": "api calls tests",
    "section": "test single address check",
    "text": "test single address check\n\ncomparable = {'Address_format': 'good',\n 'Postcode_quality': 'good',\n 'Matched': True,\n 'BestMatch': {'UPRN': '100023336956',\n  'Qualifier': 'Property',\n  'LogicalStatus': '1',\n  'Classification': 'RD04',\n  'ClassTerm': 'Terraced',\n  'Algorithm': '10-match1',\n  'ABPAddress': {'Number': '10',\n   'Street': 'Downing Street',\n   'Town': 'City Of Westminster',\n   'Postcode': 'SW1A 2AA'},\n  'Match_pattern': {'Postcode': 'equivalent',\n   'Street': 'equivalent',\n   'Number': 'equivalent',\n   'Building': 'equivalent',\n   'Flat': 'equivalent'}}}\n\nresponse = address_search(address=\"10 Downing St,Westminster,London,SW1A2AA\")\nassert response.json() == comparable",
    "crumbs": [
      "api calls tests"
    ]
  },
  {
    "objectID": "02_api_calls_tests.html#test-upload-an-encrypted-salt",
    "href": "02_api_calls_tests.html#test-upload-an-encrypted-salt",
    "title": "api calls tests",
    "section": "test upload an encrypted salt",
    "text": "test upload an encrypted salt\n\ncomparable = {\"upload\": { \"status\": \"SALTOK\"}}\n\nassert upload(infilepath=\"../data/external/test.EncryptedSalt\").json() == comparable",
    "crumbs": [
      "api calls tests"
    ]
  },
  {
    "objectID": "02_api_calls_tests.html#test-upload-a-multiple-address-check-file",
    "href": "02_api_calls_tests.html#test-upload-a-multiple-address-check-file",
    "title": "api calls tests",
    "section": "test upload a multiple address check file",
    "text": "test upload a multiple address check file\n\ncomparable = {'upload': {'status': 'OK'}}\n\nassert upload(infilepath=\"../data/external/test-addresses.txt\").json() == comparable\n\nrequests.models.Response",
    "crumbs": [
      "api calls tests"
    ]
  },
  {
    "objectID": "02_api_calls_tests.html#download-a-multiple-address-match-file",
    "href": "02_api_calls_tests.html#download-a-multiple-address-match-file",
    "title": "api calls tests",
    "section": "download a multiple address match file",
    "text": "download a multiple address match file\n\nimport time\n# GIVE TIME FOR THE UPLOAD TO BE PROCESSED DURING TESTS\ntime.sleep(10)\n\ninfilepath = '../data/external/test-addresses.txt'\noutfilepath = '../data/processed/assign-uprn.tsv'\nassert download(infilepath=infilepath, outfilepath=outfilepath).status_code == 200\n\nwritten to ../data/processed/assign-uprn.tsv",
    "crumbs": [
      "api calls tests"
    ]
  },
  {
    "objectID": "01_api_calls.html",
    "href": "01_api_calls.html",
    "title": "api calls",
    "section": "",
    "text": "python functions wrapping address-to-uprn matching api calls\n\n\nfunctions\n::: {#cell-4 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\nimport logging\nimport http.client as http_client\n:::\n::: {#cell-5 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\ndef _logger(level: int = 0):\n    \"\"\"connection logging\n\n    Args:\n        level (int, optional): [description]. Defaults to 0.\n\n    Returns:\n        Logger: details of logging\n    \"\"\"\n\n    # SET THIS TO 1 IF TROUBLESHOOTING\n    http_client.HTTPConnection.debuglevel = level\n    # You must initialize logging, otherwise you'll not see debug output.\n    logging.basicConfig()\n    # set to logging.DEBUG for details\n    logging.getLogger().setLevel(logging.ERROR)\n    requests_log = logging.getLogger(\"requests.packages.urllib3\")\n    # set to logging.DEBUG for details\n    requests_log.setLevel(logging.ERROR)\n    requests_log.propagate = True\n    return requests_log\n:::\n::: {#cell-6 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef _secrets() -&gt; tuple:\n    \"\"\"set/get environment variables from a local source outside version control\n\n    Returns:\n        str, str, str: tuple\n    \"\"\"\n    import os\n    from dotenv import load_dotenv\n\n    # take environment variables from .env.\n    load_dotenv(\"../.env\")\n    ASSIGN_ENDPOINT = os.getenv(\"ASSIGN_ENDPOINT\")\n    ASSIGN_USER = os.getenv(\"ASSIGN_USER\")\n    ASSIGN_PASS = os.getenv(\"ASSIGN_PASS\")\n    return ASSIGN_ENDPOINT, ASSIGN_USER, ASSIGN_PASS\n:::\n::: {#cell-7 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\nimport requests\n\ndef address_search(\n    address: str # An address on a single line, each element separated with a comma\n    ) -&gt; str: # json representation of the matching AddressBase Premium record\n    \"\"\"\n    Search for a UPRN by address\n\n    Example:\n\n        &gt; response = address_search('10 Downing St,Westminster,London,SW1A2AA')\n        &gt; response.json()\n        {'Address_format': 'good',\n         'Postcode_quality': 'good',\n         'Matched': True,\n         'BestMatch': {'UPRN': '100023336956',\n         'Qualifier': 'Property',\n         'LogicalStatus': '1',\n         'Classification': 'RD04',\n         'ClassTerm': 'Terraced',\n         'Algorithm': '10-match1',\n         'ABPAddress': {'Number': '10',\n         'Street': 'Downing Street',\n         'Town': 'City Of Westminster',\n         'Postcode': 'SW1A 2AA'},\n         'Match_pattern': {'Postcode': 'equivalent',\n         'Street': 'equivalent',\n         'Number': 'equivalent',\n         'Building': 'equivalent',\n         'Flat': 'equivalent'}}}\n    \"\"\"\n\n    # GET AUTHENTICATION DETAIL FROM .ENV\n    ASSIGN_ENDPOINT, ASSIGN_USER, ASSIGN_PASS = _secrets()\n\n    response = requests.get(\n        f\"{ASSIGN_ENDPOINT}/api2/getinfo?adrec={address}\", auth=(ASSIGN_USER, ASSIGN_PASS)\n    )\n    return response\n:::\n::: {#cell-8 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\nimport requests\nimport os\n\ndef upload(\n    infilepath: str, # filepath containing multiple addresses to upload\n    debugLevel: int = 0 # optional, used during development\n) -&gt; requests.models.Response: # API response confirming whether upload OK\n    \"\"\"\n    Upload text file of TSV address records to the ASSIGN API, OR upload an encrypted salt\n    \n    For address uploads, format is two columns: id and address, e.g.:\n    1   10 Downing St,Westminster,London,SW1A2AA\n    1   11 Downing St,Westminster,London,SW1A2AA\n\n    Example:\n\n        &gt; infilepath='../data/external/test-addresses.txt'\n        &gt; upload(infilepath=infilepath).json()\n        {'upload': {'status': 'OK'}}\n\n        OR FOR SALT\n\n        &gt; infilepath='../data/external/test.EncryptedSalt'\n        &gt; upload(infilepath=infilepath).json()\n        {\"upload\": { \"status\": \"SALTOK\"}}\n\n    \"\"\"\n\n    # useful for debugging http activity\n    if debugLevel == 1:\n        _logger()\n\n    # GET AUTHENTICATION DETAIL FROM .ENV\n    ASSIGN_ENDPOINT, ASSIGN_USER, ASSIGN_PASS = _secrets()\n\n    # HTTP POST request\n    url = f\"{ASSIGN_ENDPOINT}/api2/fileupload2\"\n\n    files = {\n        \"file\": (os.path.basename(infilepath), open(infilepath, \"rb\"), \"text/plain\")\n    }\n    response = requests.post(url, files=files, auth=(ASSIGN_USER, ASSIGN_PASS))\n\n    return response\n:::\n::: {#cell-9 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\nimport requests\nimport os\n\ndef download(\n    infilepath: str, # filename of the previously uploaded file\n    outfilepath: str = '../data/processed/assign-uprn.tsv', # filepath to store the response in\n) -&gt; requests.models.Response: # API response containing content to output to TSV file\n    \"\"\"\n    Download TSV data matching previously upload txt file of TSV addresses\n    \n    Example:\n    \n        &gt; infilepath = '../data/external/test-addresses.txt'\n        &gt; download(infilepath=infilepath).status_code\n        200\n\n    \"\"\"\n\n    # GET AUTHENTICATION DETAIL FROM .ENV\n    ASSIGN_ENDPOINT, ASSIGN_USER, ASSIGN_PASS = _secrets()\n\n    # HTTP GET request\n    url = f\"{ASSIGN_ENDPOINT}/api2/download3\"\n\n    # TRIM PATH TO FILENAME ONLY (FOR IDENTIFICATION BY ASSIGN)\n    params = {\n        \"filename\": os.path.basename(infilepath),\n    }\n\n    response = requests.get(\n        url, params=params, auth=(f\"{ASSIGN_USER}\", f\"{ASSIGN_PASS}\")\n    )\n\n    with open(outfilepath, \"wb\") as f:\n        f.write(response.content)\n        print(f\"written to {outfilepath}\")\n\n    return response\n:::\n::: {#cell-10 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\nimport nbdev\n\nnbdev.nbdev_export()\n:::",
    "crumbs": [
      "api calls"
    ]
  }
]